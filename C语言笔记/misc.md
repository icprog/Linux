


```c

1、#include<file.h>与#include"file.h"的区别
前者表示编译器在标准库路径搜索file.h。
后者表示编译器在用户的工作路径搜索file.h，如果找不到，再去标准库路径搜索。

2、const的作用
（1）修饰变量，表示在编译期间该变量的值不能被修改，不能出现在赋值号=的左边，不能作为左值。
（2）修饰函数的形参，表示在该函数内不能修改这个形参，起保护作用。一般修饰函数形参指针。
（3）修饰函数的返回值，表示函数的返回值不能被修改。也就是该函数表达式不能作为左值。
（4）C++中const修饰的函数称为常成员函数，常成员函数不能修改对象的数据成员，不能调用非const成员函数，只能调用const成员函数。

3、在C++程序中调用C编译器编译后的函数，为什么需要加 extern "C"？
C++支持函数重载，它编译函数后会将函数参数类型也加入编译代码。
C不支持函数重载，编译后一般只包含函数名。
假如有一个C函数为：void foo(int x, int y);
它被C编译器编译后在库中的名字为：_foo。
它被C++编译器编译后在库中的名字可能是：_foo_int_int。
extern "C"提示C++编译器将该函数按照C语言风格来编译。

4、关于free()函数
测试程序：

int main(void)
{
	char *str=(char *)malloc(100);
	strcpy(str,"hello");
	printf("str=0x%x\n",str);
	free(str);
	printf("str=0x%x\n",str);
	return 0;
}

输出：
str=0x1d8c010
str=0x1d8c010
在free(p)之后，p成为野指针，必须p=NULL;
free仅仅接触p和它指向的内存之间的联系，p保存的值没有清除。

5、sizeof和strlen
（1）、sizeof数组


#include<stdio.h>

void func(char str[100])
{
	int inFunc = sizeof(str);
	printf("inFunc=%d\n",inFunc);
}

int main(void)
{
	char str[100];
	int inMain = sizeof(str);
	printf("inMain=%d\n",inMain);
	func(str);
	return 0;
}

在64bit Ubuntu中输出：
inMain=100
inFunc=8
（2）sizeof和strlen的区别
sizeof计算某个变量在内存中占用的大小。
strlen计算某个字符串的长度，在计算长度时，它遇到'\0'会停止计算，然后返回长度。

6、C语言的运算符
（1）.逗号运算符


#include<stdio.h>
int main(void)
{
	int i,j;

	j=(i=1,2);
	printf("i=%d,j=%d\n",i,j);
}

输出：i=1,j=2

（2）运算符优先级
.运算符高于*，例如：
*p.member;    表示 *(p.member);

.和->的优先级高于*和&。
&p->member;        表示 &(p->member);

（3）、逻辑运算符
|| && !

（4）、C语言运算符优先级表：C语言深度解剖：P84

7、 int 会被隐式转换成unsigned int。

9、补码
正数的原码、反码、补码都一样，就是它本身。
在原码转换成补码的过程中，负数的最高位符号位不参与运算。
所有负数补码的最高位都是1.

10、C语言的getchar函数原型为：
int getchar(void);
返回用户输入的ASCII码或者EOF。

11、register变量
它不存放在内存中，所以不能对它使用取地址运算符"&"来获取register变量的地址。

12、 static变量
当它在一个函数内修饰静态局部变量时，它只会被初始化一次，它存储于内存的静态区。
即使这个函数退出了，这个静态局部变量的值也不会被销毁。

13. 任何以0开头的数据，都是八进制数。0x除外。例如：056，077。

14、反斜杠 \
(1)用作接续符：它表示断行，在编译时，编译器会把反斜杠删掉，同时把反斜杠后面的字符自动的接到前一行。接续符常用于宏定义。
(2)用作转义字符。如 \n表示换行，\d \dd \ddd表示八进制数ddd所代表的字符，\xh \xhh \xhh表示十六进制hh代表的字符。

15、字符串
(1)字符串都是以'\0'结尾的。
"1"占2个字节。
1占4个字节，它是整型。
'1'占1个字节，它是一个字符。

(2)在给数组赋值时要注意：
char a[]="1234";//a占5个字节，最后一个成员a[4]='\0';
char a[]={'1','2','3','4'};//它占4个字节，最后一个成员a[3]='4';
char a[]={'1','2','3','4','\0'};//a占5个字节，最后一个成员a[4]='\0';

(3)0 '0' '\0' ' ' ''的区别
0 表示数字0，是一个整型，占4个字节。ASCII码的转义字符为：'\x30'
'0' 表示字符0，是一个char型，占1个字节。ASCII码的转义字符为：\x30'
'\0' 表示空字符，占1个字节。ASCII码的转义字符为：'\0'
' ' 表示空格字符，占1个字节。ASCII码的转义字符为：'\20'
'' 表示啥也没有，不能这样赋值，gcc编译报错。
ASCII码占一个字节。

16、C语言中，内存的代码区，静态区，常量区，堆区，栈区有什么区别？
(1)代码区：存放程序的代码，即CPU执行的机器指令，它的内存是只读的。
(2)静态区：全局区，存放全局变量和static变量，只有当程序运行结束时，静态区的内存才会被释放。
(3)常量区：存放常量，程序运行期间不能被修改的量，如数字 10，字符串"abcde"等。
(4)堆区：使用malloc或者new分配的内存，必须使用free或者delete释放，否则会产生内存泄露。它的空间比较大。
(5)栈区：存放函数的局部变量，形参，返回值。在函数调用结束时，它的内存会被回收。它的空间比较小，但效率高。

17、关于大小端模式
(1)小端模式(little-endian)：低字节存放在低地址，高字节存放在高地址。
(2)大端模式(big-endian)：高字节存放在低地址，低字节存放在高地址。
(3)网络字节序：TCP/IP各层协议定义为大端模式，称为网络字节序。

(4)unsigned int 和 signed int的隐式转换


int main(void)
{
	int m = 0x98967492;
	char *p=(char *)&m;
	
	printf("p=%x, *p=%02x\n",p,*p);
	printf("p+1=%x, *(p+1)=%02x\n",p+1,*(p+1));		
	printf("p+2=%x, *(p+2)=%02x\n",p+2,*(p+2));
	printf("p+3=%x, *(p+3)=%02x\n",p+3,*(p+3));
	
	printf("\n");
	
	p=(char *)&m;
	
	printf("p=%x, *p=%d\n",p,*p);
	printf("p+1=%x, *(p+1)=%d\n",p+1,*(p+1));		
	printf("p+2=%x, *(p+2)=%d\n",p+2,*(p+2));
	printf("p+3=%x, *(p+3)=%d\n",p+3,*(p+3));	

	return 0;
}

打印出：
p=aee039b4, *p=ffffff92
p+1=aee039b5, *(p+1)=74
p+2=aee039b6, *(p+2)=ffffff96
p+3=aee039b7, *(p+3)=ffffff98

p=aee039b4, *p=-110
p+1=aee039b5, *(p+1)=116
p+2=aee039b6, *(p+2)=-106
p+3=aee039b7, *(p+3)=-104

打印出ffffff的原因：%x期望的类型是unsigned int,但是传给它的类型int，默认为signed int。
如果最高位为1,就会被认为是负数，将它进行隐式转换成unsigned int。
修改成下面的即可：

int main(void)
{
	unsigned int m = 0x98967492;
	unsigned char *p=(unsigned char *)&m;
	
	printf("p=%x, *p=%02x\n",p,*p);
	printf("p+1=%x, *(p+1)=%02x\n",p+1,*(p+1));		
	printf("p+2=%x, *(p+2)=%02x\n",p+2,*(p+2));
	printf("p+3=%x, *(p+3)=%02x\n",p+3,*(p+3));
	
	printf("\n");
	
	p=(char *)&m;
	
	printf("p=%x, *p=%d\n",p,*p);
	printf("p+1=%x, *(p+1)=%d\n",p+1,*(p+1));		
	printf("p+2=%x, *(p+2)=%d\n",p+2,*(p+2));
	printf("p+3=%x, *(p+3)=%d\n",p+3,*(p+3));	

	return 0;
}

打印出：
p=56645614, *p=92
p+1=56645615, *(p+1)=74
p+2=56645616, *(p+2)=96
p+3=56645617, *(p+3)=98

p=56645614, *p=146
p+1=56645615, *(p+1)=116
p+2=56645616, *(p+2)=150
p+3=56645617, *(p+3)=152


（5）写2个函数，用来区分小端还是大端模式。


方法1：
int isLittenEndian(void)
{
	unsigned int m=0x98765432;
	unsigned char *p=(unsigned char *)&m;

	if(*p == 0x32)
		return 1;//is little endian
	else if(*p == 0x98)
		return 0;//is big endian
}

方法2：联合体union的存放顺序是所有成员都从低地址开始存放，而且所有成员共享存储空间：
int isLittenEndian(void)
{
	union Temp{
		unsigned int a;
		unsigned char b;
	}temp;

	temp.a = 1;
	return(temp.b == 1)
}


18、原码，反码，补码
(0)
在计算机中，存储的都是补码。比如打印出来的地址、数字、字符等，都是以补码形式存储的。
(1)
不管是signed类型还是unsigned类型，原码、反码和补码是针对负数的.
正数的原码、反码，补码都相同，就是将它的二进制的值。
(2)
对于unsigned变量，最高位可以使用。
对于有符号signed变量，最高位不能使用，它被当做符号位来区别正数和负数，正数为0，负数为1。
如果没有显式定义unsigned，默认都是signed变量。
(3)
对于负数，原码是将它转换成二进制，最高位为符号位不变，为1。
反码是将原码取反，最高位符号位不变。
补码是反码加1，最高位符号位不变。
(4)
将补码转换成原码：减1，取反，添加负号-。(负数的补码转换成原码，符号位不参与运算)
将原码转换成补码：取反，加1，符号位不参与运算。
(5)
1000 0000表示 -128。-128实际上是使用以前的-0的补码来表示的， 所以-128并没有原码和反码。
(6)
原码1111 1111表示 -127。它的补码为： 1000 0001
(7)
符号位仅仅用来区分正数和负数，不需要参与运算。
(8)
对于负数，无论是原码转换成补码，还是补码转换成原码，最高位符号位都不用参与运算。
所有负数的补码的最高位一定为1。

19、一道关于有符号数组的题目


int main(void)
{
	char a[1000];
	int i;
	
	for(i=0; i<1000; i++){
		a[i]=-1-i;
	}
	
	printf("%d",strlen(a));
	return 0;
}

输出： 255
分析：
i=0,a[0]=-1,二进制原码： 1000 0001。二进制补码： 1111 1111，即0xff
i=1,a[1]=-2,二进制原码： 1000 0010。二进制补码： 1111 1110，即0xfe
......
i=126,a[126]=-127,二进制原码： 1111 1111. 二进制补码： 1000 0001，即0x81
i=127,a[127]=-128,-128没有原码和反码，它的二进制补码为：1000 0000，即0x80
i=128,a[128]=-129,超过了 signed char 所能表示的最小数字，发生溢出. -129的二进制原码为： 1 1000 0001，转换成补码： 1 0111 1111.丢弃最高位： 0111 1111，即0x7f
......
i=254,a[254]=-255,原码： 1 1111 1111   补码： 1 0000 0001,丢弃最高位， 0000 0001,即0x01 
i=255,a[255]=-256,原码： 11 0000 0000  补码： 11 0000 0000,丢弃最高位， 0000 0000,即0x00
i=256,a[256]=-257,原码： 11 0000 0001  补码： 10 1111 1111,丢弃最高位， 1111 1111，即0xff
i=257,a[257]=-258,原码： 11 0000 0010  补码： 10 1111 1110,丢弃最高位， 1111 1110，即0xfe
......
可以看到，a[255]=0.strlen计算字符串的长度，遇到'\0'，即停止计数，所以a的长度为255.

20、再看一个有符号和无符号数相加的例子


int main()
{
	int a = -6;
	unsigned int b = 4;
	
	if(a+b > 0)
		printf("a+b>0\n");//这句话被打印
	else
		printf("a+b<0\n");
		
	int z = a+b;
	
	if(z > 0)
		printf("z>0\n");
	else
		printf("z<0\n");//这句话被打印

	return 0;
}

分析：
int 和 unsigned int 相加时，int会被隐式转换成 unsigned int。
int 类型的负数最高位为符号位1，所以int类型的负数会被转换成一个很大的正数。2个正数相加，为正。
z= a+b，把 a+b 的结果当做 int 类型了，它的最高位为1，所以 z 是一个负数。

21、关于return
一个例子：
int main(void)
{
	int a=0;
	return a;
}
a是局部变量，为什么可以return a？
分析：这里返回的是局部变量的值，在return时，会进行一次拷贝的操作，实际上返回是的拷贝后的那个变量，原来的变量a在函数退出后栈被释放了。
所以，不能return 局部变量的指针，但是可以return 局部变量的值。
实际上，跟函数形参和实参的“传值”类似，都要经过一次拷贝操作。

22、const和volatile同时修饰同一个变量
const volatile int time = 19;
分析：
编译期和运行期。
编译期指的是编译器将C代码编译成汇编代码的过程。
运行期指的是二进制代码的运行过程。
被const修饰的变量，在编译期，不能作为左值存在，否则编译报错。
被volatile修饰的变量，在编译期，编译器不能对它进行优化。在运行期，每次读它都必须从内存中去取，不能使用寄存器中的备份。

23、
发现在cpp中，函数声明不需要加extern，只需要使用前声明就行了。
原因：在cpp中，声明外部函数时，可以省略extern。

24、枚举变量的本质，相当于int。
enum FFFF{
	TTT,
	EEE,
	HHH,
	GGG
}val;
val=TTT;

25、
在C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针。
在C语言中，所有非数组形式的数组实参均以传值的形式调用（对实参做一份备份并传递给被调用的函数）。

26、预处理命令


#define
#undef
#include
#if
#elif
#else
#endif
#ifdef
#ifndef
#error message 当编译的时候遇到 #error ，就会生成一个编译错误信息message，然后停止编译。

```



